# T3A1

## Q1 Provide an overview and description of a standard source control process for a large project

### Description:

The standard source control process for a large project has the following key features:

- It is tool based. Source control is achieved using tools such as Git or Jira rather than by some manual means.
- The tool is hierarchical. Standard source control tools utilise a client - server based architecture rather than a distributed peer-to-peer system.
- A canonical version exists. Owing to the above, at any given time a correct version of the source that is priveliged in its veracity above all other versions exists.
- Asynchronous development is enabled by version merging. Canonicity is maintained by merging other versions into the canon version instead of by locking the canon version while it is edited. Versions of the source are typically called branches.
- Other details appear not to have strongly defined standards which might be described.

### Overview:

1. A canonical branch is created or designated by a SCM
2. A developer creates a copy (local or otherwise) of the canonical branch
3. The developer uses the copy to create a non-canonical branch
4. The developer makes changes to the non-canonical branch
5. The developer attempts to merge her non-canonical branch into the canonical branch typically following review of the changes by a peer or superior
    - If others have made changes to the canonical branch while the developer worked on her non-canonical branch then conflicts may arise between the branches that are to be merged.
    - In the latter case additional intervention and case-specific business rules will be applied.

- In certain cases the non-canonical branch may not be merged back into the canonical branch. This may occur because:
    - Branch incompatibility could not be resolved,
    - The development goals of the branch were not met, or;
    - Because a decision is made to create a new softrware version based on the non-canonical branch (in which case the non-canonial branch becomes a new canon).

## Q2 What are the most important aspects of quality software?

Within three dimensions Dave Chappel defines measures by which software quality might be measured: 

1. Functional. Which refers to the fitness of the software for its purpose by end users. 
    1. How well the software meets its specified requirements. 
    2. How few defects the software exhibits. 
    3. How performant the software is. 
    4. How easy to learn and use the software is.
1. Structural. Which refers to the characteristics of the source code underlying the software.
    1. How testable the code is. 
    2. How maintainable the code is. 
    3. For comprehensible the code is. 
    4. How efficient or concise the code is. 
    5. How secure the code is. 
1. Procedural. Which refers to the non-computing related qualities of the software. 
    1. Timeliness of delivery. 
    2. Budgetary conformance. 
    3. Repeatability.
  
Chappel notes that the relative importance of any of these measures and dimensions is likely to depend on the context, users and requirements of the software. The author notes that, despite the question, the rubric requires no assessment of importance.


## Q3 Outline a standard high level structure for a MERN stack application and explain the components

The standard high level structure of a MERN stack application is a non-relational MongoDB database, a client-side user interface generated by React and an Express.js framework running on a Node.js server.

- Front End - React. Generates an interface for the browser to display for the user. It receives information from Express.js to do this in JSON form. It communicates user actions and data backwards to Express.js using XML HTTP requests or GET/POST HTTP requests.
- Middle End - Express/Node.js. Node.js receives HTML requests and translates them to server functions that are carried out to dictate the logical behaviour of the application. When stored information is required it is requested from MongoDB via Node.js drivers using callbacks or promises.
- Back End - MongoDB. MongoDB stores data as compressed JSON. It receives requests for data from the middle end and provides it as JSON, and receives data for storage from the middle end in JSON format and stores it after any necessary processing occurs.


## Q4 A team is about to engage in a project, developing a website for a small business. What knowledge and skills would they need in order to develop the project?

The following knowledge and skills would be necessary to develop the project:

- Development of dataflow diagrams that strictly follow the standard convensions to clearly identify the processes within the application, clearly depicting where data is coming from, where it is going and how it is being stored.
- An understanding of the planned architecture of the application.
- The development of user stories that in the format "persona, what and why" that outline meaningful features of the project, along with revision and refinement of those stories.
- Development of wireframes for planning project flow and structure, including sound consideration of space distribution, content prioristiation, intended actions, functions and relationships between screens.
- Use of a common planning methodology.
- DRY principles; every piece of knowledge has a single, unambiguous, authoritative representation
- Use of extgernal and internal libraries including a complete and detailed description of libraries used in the app in documentation and comments.
- Code flow control
- Use of object oriented principles/patterns; use of OO principles/patterns throughout application with positive impact on code maintainability and serviceability
- Code highly organized and clearly commented; use of functions to improve code serviceability and maintenance
- Use of highly sophisticated functions, ranges and classes
- Employment of proper source control
- Employment of and adherence to simple and clear standards for planning
- Development of an app that at least meets user and client expectations.
- Deployment to a cloud hosting service, using environment variables, with the same database type in development/testing as production, with a custom domain name
- Development of a user-interface that is highly intuitive, with no impediments to user flow
- Achievement of user-testing of development site
- Achivement of user-testing of production site, including by client
- Utilisation of a comprehensive test suite including both unit and integration tests in both backend and frontend, with extensive code coverage
- Employment of task delegation methodology demonstrating consideration of strength and weaknesses of team members and project/team conditions

## Q5 With reference to one of your own projects, discuss what knowledge or skills were required to complete your project, and to overcome challenges
I undertook reform of the learning design, management packages, associated resources and quality assurance for the intial employment training of one of the largest trades in the Army to enhance the throughput, improve quality and improve efficiency in the lead up to employment category and pay review, and to set the conditions for modernisation of the capability the trade delivered.

The first key skill required achieve each of the sub-components was leadership; since tasks of that size cannot be carried out by individuals in a timely manner effective delegation was essential. The subcomponents of this high-order skill that were most critical were the identification of individual's skills and motivations, synthesised with an understanding of the skills necessary for task achievement to enable synergetic alignment and to ensure best effort. This understanding of necessary skills was, in turn, informed by the prior development of mastery over the related subject knowledge through the management of learning design, delivery and audit for the trades in question. The most accurate term for this epistemic relationship is probably something like meso-knowledge, which is the inverse of meta-knowledge. The ability to identify subordinate and peer motivations was combined with the ability to modify them with inspirational or transactional actions if correction was required.

The second key skill was the ability to consistently apply attention to detail to ensure that the project was being carried out to the standards of quality that had been specified in the time frame required, and that the changes were actually of the character intended. This sometimes depended on the motivational skills above, but more often relied on the meso-knowledge discussed above since subordinates usually genuinely did want to provide best output but sometimes didn't know how. 

The final key skill was the ability to generate, preserve and spend the political capital necessary for change. The changes in question required authority and resources I did not possess, as well as consensus from a diverse range of influential stakeholders. The ability to convince others that implementation of these reforms were desirable was central to this; the more fundamental skill of persuasion was necessary to ensure that capital expenditures were as efficient as possible. Political capital was generated through a combination of reputation, favours and credibility, preserved through careful risk and perception management and spent judiciously by seeking decision or support only at the times necessary for the decision points where it was necessary. This implies a related skill of conceptualising the dependency tree of a complex project so that tasks can be correctly sequenced and prioritised.

## Q6 With reference to one of your own projects, evaluate how effective your knowledge and skills were for this project, and suggest changes or improvements for future projects of a similar nature
I have an ongoing program that I manage which involves a sequence of projects where I make breakfast every morning for myself. It is considered that most skills are adequate to the project, including those related to  food procurement, meal selection and preparation, inventory management, kitchen and utensil maintenance and appliance use, but some deficiencies have been identified.

At an after-action-review for breakfast last week it was identified by the (one man) Continuous Breakfast Process Improvement Committee that the method employed for coffee dosing had an unacceptable error rate and a fix was required. The committee drilled down into the process and discovered that the process involved measuring the amount of instant coffee used for coffee dosage by eye, with the operator directly pouring instant coffee from the jar into into a mug while simultaneously and dynamically assessing whether the correct amount had been reached. The committee conducted further analysis and discovered that this method also generated waste in the form of spillage which required time investment for cleanup and produced inconsistent coffee dosage.

The root cause was assessed to be insufficient pouring skill by the operator and poor prior knowledge of the factors contributing to flow rate variation (for eg, pour angle, brand dependent density of instant coffee, humidity, dynamic friction of granules caused by different 'tapping' techniques). Additional training was considered but determined to be unfeasible, since the method in use had an skill floor that was untenably high for the target workforce due to the dynamic nature of the method combined with the the poor hand-eye coordination and fine-motor control subskills of the target workforce during the morning hours when the project occurrs.

The committee resolved that a modification to the method was required. From Sunday 01 May 22 the operator would instead use a spoon to dose coffee. This would alter the skill required from a dynamic-feedback related skill to a more repeatable and static skill using a tool, with a far lower skill floor that was largely independent of fine motor control.

The method was initially rolled out on schedule. The operator used a table spoon to dose the coffee (two tablespoons per mug). The first dosing manouevre was successful, however during the second the operator lost awareness of the location of his elbow while transferring the coffee to the mug. As a result of this lapse his elbow came into contact with the boiling jug, causing a flinch reaction, which in turn caused the dose to be spilled. Rectification was abnormally costly in terms of time and breakfast mood suffered from negative affect as a result.

Initial internal review of the change management process by the committee suggests that the SKA assessment for the new method was probably inadequate which resulted in an underestimation of the coordination and gross motor requirements for the new dosing method, although the committee accepts that it cannot excluse that the cause may also have been caused by overestimation of target workforce gross-motor and hand-eye coordination skills. The committee also concedes that it is possible that the incident was caused by workforce unfamiliarity with the new process. In any case the committee's initial assessment is that training in preparation for the new coffee dosage method was inadequate which resulted in a skill gap which was the direct cause of the incident.

Further improvement for future project iterations is required. An additional procedure has been put in place to mitigate operator gross motor risks. The operator is now required to complete dosing of coffee prior to activation of the kettle. This reduces concurrency but improves reliability. It is considered that the average time taken to complete the task will probably be similar, but the reduction in standard deviation is more valuable. Additionally it is considered likely that the target workforce's co-ordination and motor control skills (both fine and gross) is unlikely to improve and is, in fact, likely to continue to diminish in the coming years due to the onset of middle age, which provides further support for a control-based appraoch to improvement of this procedure. The committee also considered the possibility of knowledge-based improvements but considered that even if the pouring variables could be accurately quantified for the purpose of inculcation, they couldn't be measured reliably enough in the workplace for the additional knowledge to be applicable, further reducing support for a training-based approach to outcome improvement.

Finally, the committee considered deploying capital to resolve the evident workforce-needs gap. The committe considers that automation in the form of a coffee machine may produce more reliable results independent of workforce skills, but notes that coffee machines make disgustingly weak coffee, almost like brown water. If performance lapses continue the committee will raise capital resolution of the issue to the finance delegate (wife) for consideration but this is considered an undesirable course of action.

## Q7 Explain control flow, using an example from the JavaScript programming language

Flow is the order in which elements of a program are executed or evaluated. Control flow is thus the imposition of intent on the natural flow. The method used on javascript to impose intent is statements, known as control flow statements. Modification of a natural order is usually in the form of conditions, for example using an if – else statement will cause one section of code to be executed if a defined condition is met, otherwise another section labelled else will be executed. An example is shown below.

    function questionEffort(question, previousassessments) {
        if (previousassessments.includes(question.qtext)) { // this line starts declares that an if control structure is being imposed with the if keyword
        // once if is declared JS will consider the truthfulness of a statement in the () brackets, here dependent on argument input
        // if true is resolved then JS will execute the code in the {} brackets, otherwise it will go to the next conditional statement
            return false; // return is a keyword that will cause no additional execution of code within this function; instead a value will be returned to the function context determined by whatever is in the same statement as return
        } else if (question.rubric.includes('Self reflection')) { // this is the next conditional statement, which in JS is declared by the keyword "else if" for not-last statements after the first in cases where many evaluations will occur
        // else if is otherwise functionally identical to if; evaluation of () statement determines whether code in {} will be executed
            return false;
        }
        else { // else is the final keyword in this control structure for cases where no if statements are evaluated to true else will execute code in its {} but will not execute in other cases
            return true;
        }
    }

## Q8 Explain type coercion, using examples from the JavaScript programming language

Type coercion is the act of the alteration of subject datum type, for example from a string to a number or vice versa. Coercion takes two forms in JS, implicit and explicit. Explicit type coercion can cause loss of information in JS and must be explicitly called with a method, but implicit cannot. On a deeper level coercion also occurs to operators, although the behaviour is not documented as such. An example of each type is below:

    const stringnum = '3';
    const numnum = 1;
    let concated = stringnum + numnum;

    console.log(concated);
        // will output '31'
        // Why?
            // The engine will make the decision to coerce the variable numnum from
            // number type to the string type, and interpret the + operator as concat.
        // Why?
            // Because the language ECMAScript languge specification dictates that
            // if any + operation is called where one of the arguments is a string
            // then the + operation is to be interpretted as concat and all non-string
            // arguments are to be coerced to string type.
        // Why?
            // Because JS was designed in two weeks and idosyncracies like this
            // now can't be changed without breaking legacy systems.

        // Therefore to have the + operation be interpretted as arithmatic addition
        // we must first explicitly coerce stringnum to the type number using Number()

    let addition = Number(stringnum) + numnum;
    console.log(addition);
     // will output 4

## Q9 Explain data types, using examples from the JavaScript programming language
When I did this question two terms ago for Ruby I explained data types from first principles using the primitives that underly Ruby and got, like, 1 mark. I actually maintain that was a more complete and correct answer than the desired one which was suggested and which, no doubt, others got good marks for since "under the hood" Ruby _is_ using these primitives for all its operations. This is also true in JS. You're a captive audience, and I think I can meet the HD criteria for _this_ assignment by arguing the toss on the same question. So let's go.

High level languages do not use their own data types for anything except user display (ie the "developer" in a high level language is just a user of the software, which is an interpretter. The interpretter is a program in a lower level language that takes a high level "program" as an argument and returns a compiled binary for execution, possibly with additional intermediate iterations with bytecode etc in between, for example in the case of Ruby where at the first layer bytecode will be generated for use by a virtual machine, which in turn will generate binary for execution on a real machine). This is to say that types in high level languages do not fundamentally exist; they are a consensus-based fiction providing a wrapping for programmer ease. JS "data types" and "primitive types" are thus just abstract wrappers for the underlying language primitives.

So, for example, an object properly defined IAW JSON standards is _not_ a data type in JS. It is, by _definition_ (in RFC7159) a container for collection of one or more values belonging to JS types which are themselves by _definition_ a wrapper for JS primitive types which are themselves wrappers for the engine's (almost always C++ but sometimes other) compiled language primitives, which are themselves (almost 1:1) representations of asm/binary data structures. That is to say; all JS (and high level) types are necessarily composed and derived from underlying compiled primitives (ie again, JS types are necessarily composite and derived types; this necessity in turn necessarily implies the existence of primitives as a component of any JS implementation; further this analysis perfectly generalises to all high level languages).

To reinforce this conclusion, consider that primitives _physically exist_. That is to say that they are descriptions of configurations of embodied information. It is definitionally impossible, for example, to describe a compiled primitive that cannot actually exist but it is trivial to do so with high level types. High level data types exist only logically if they are atomic; this is equivalent to saying they are imagined by programmers, which is adjacent to the statement that they don't exist. Note: This distinction is meaningful and not simply semantic since the specification for JS necessarily requires that types cannot exist in their specified form, since they are defined only through their relationships and behaviours, and never in certain terms. The specification leaves implementation of the types to engine writers, _who must necessarily implement them using compiled primitives_. Thus it is necessarily true that the existence of compiled primitives is more real in all cases than the existence of high level data types since for all definitions of real, type and data the former is necessary for the latter. Put another way, all JS (and high level) types are necessarily composed and derived from underlying compiled primitives. 

### To cover all bases
- Type in this context means an attribute of information (or data) that controls how it is evaluated, operator on and stored.
- The data types that JS uses are string, number, bigint, boolean, undefined, symbol and null.

- A really good example of a data type in JS is the type number, which describes _all_ numbers below the size of a bigint. JS has no way to natively differentiate between different types of numbers beyond this.
  - This means, for example that an inbuilt functions setTimeout and setInterval, which accept a number as an input but require int32 to function correctly, require the addition of manually constructed helper functions to prevent undocumented behaviour since JS has no native understanding of whether whether the provided argument is an integer, let alone signed, signed correctly or within a range of values that int32 can hold. This is all _despite_ having an int32 constructor function and is directly caused by using a single weak number supertype. Note that an int32 produced by JS' inbuild constructor function will cause an error if provided as an argument for inbuilt JS functions which require int32 input, since the JS constructor function outputs an array, not a number.
  - This is indicative of a more general and serious problem with the weak number supertype paradigm in JS, which is that because the underlying primitive cannot be known or guaranteed the operations on that number cannot be sufficiently optimised with respect to target hardware. This results in necessarily and excessively unperformant programs which has rendered JS unsuitable for many applications. This has contributed to the necessity of web assembly.
- An example of a more primitive and better defined data type is type fp64 outlined in IEEE 754-2008 (called a double prior to the 2008 revision of the standard, and still called a double in many programming languages that were defined prior to 2008) which expresses numbers with 1 sign bit, 11 exponent bits and 52 fractional bits allowing whole or decimal numerical values between −9,007,199,254,740,992 and +36,028,797,018,963,968 to be expressed with levels of precision that vary predictably depending on the size of the number. Being able to have certainty about the storage format, precision and size of the number has very strong functional advantages in terms of safety and performance.
    - Note also that I'm not making general claims about weak vs strong, or dynamic vs static typing in commentary on the examples. The claims are specific to the JS number type in comparison to the fp64 (int32 etc) type.
    - For even further clarification; it's not necessarily bad that JS has a weak supertype for numbers, but it is necessarily bad that it _enforces_ the weak supertype and has no native ability to comprehend more specific or stronger typing of numbers. It seems almost certain that the reason that JS maintains these indiosyncracies is for backwards compatibility, which is to say that even if it were universally acknowledged that the paradigm were bad it would be retained because fixing it would break legacy systems.
    - But that's the price you pay for being the most popular language.

## Q10 Explain how arrays can be manipulated in JavaScript, using examples from the JavaScript programming language

Arrays can be manipulated with programmer-defined functions, which can have virtually any behaviour, or with inbuilt functions which are defined in 22.1 of ECMAScript 262 2020 Language Specification (v11).

The inbuilt (non-prototype) array functions are: concat(), copyWithin(), entries(), every(), fill(), filter(), find(), findIndex(), forEach(), from(), includes(), indexOf(), isArray(), join(), keys(), lastIndexOf(), map(), pop(), push(), reduce(), reduceRight(), reverse(), shift(), slice(), some(), sort(), splice(), toString(), unshift() and valueOf(). Each provides different output. Additional functionality is provided by prototype functions.

An example of user-defined array-manipulation, building a 2d matrix of 3x3 size filled with words from a string:

    var 2dmatrix = new Array(3);
    var h = 0;
    var word = "Theseletterswillfilla3x3array";

    document.write("Creating 2D array <br>");
    for (var i = 0; i < 2dmatrix.length; i++) {
        2dmatrix[i] = [];
    }

    for (var i = 0; i < 3; i++) {
        for (var j = 0; j < 3; j++) {
            2dmatrix[i][j] = word[h++];
        }
    }

    for (var i = 0; i < 3; i++) {
        for (var j = 0; j < 3; j++)

        {
            document.write(2dmatrix[i][j] + " ");
        }
        document.write("<br>");
    }
    // ignoring the string gimick this function could be used to generate 2d graphics, or using vector transforms, act as the basis for further functions to generate 3d graphics


## Q11 Explain how objects can be manipulated in JavaScript, using examples from the JavaScript programming language

Objects can be manipulated with programmer-defined functions, which can have virtually any behaviour, or with inbuilt functions which are defined in 20.1 of ECMAScript 262 2020 Language Specification (v11).

The inbuilt object functions are: Object.assign(), Object.create(), Object.defineProperties(), Object.defineProperty(), Object.entries(), Object.freeze(), Object.fromEntries(), Object.getOwnPropertyDescriptor(), Object.getOwnPropertyDescriptors(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), Object.getPrototypeOf(), Object.hasOwn(), Object.prototype.hasOwnProperty(),Object.is(), Object.isExtensible(), Object.isFrozen(), Object.prototype.isPrototypeOf(), Object.isSealed(), Object.keys(), Object.preventExtensions(), Object.prototype.propertyIsEnumerable(), Object.seal(), Object.setPrototypeOf(), Non-Standard Deprecated, Object.prototype.toSource(),Object.prototype.toString(),Object.prototype.valueOf() and Object.values().

An example of a programmer-function for manipulating objects composed of inbuilt methods:
    function badQuestionDeleter(question, previousassessments) {
            if (previousassessments.includes(question.qtext)) {
                delete question.qtext
                // delete deletes a property of an object, ie not the key or the value but the property
                break
            }
            else {
                return question
            }
        }

## Q12 Explain how JSON can be manipulated in JavaScript, using examples from the JavaScript programming language

To manipulate JSON in JS it's necessary to convert between string and object form. To go from string to object JSON.parse() must be called, from object to string JSON.stringify() must be called, as shown by:

    const obj = {1: "A", 2: "B", 3: "C", 4: "D"};
    const newJSON = JSON.stringify(obj);
    console.log(newJSON)
    // will output '{1: "A", 2: "B", 3: "C", 4: "D"}'

    const reverted = JSON.parse(newJSON);
    console.log(reverted)
    // will output {1: "A", 2: "B", 3: "C", 4: "D"}

These functions can also be used on JS arrays with identical function.

From there the data may be manipulated with functions appropriate to either strings or objects. Dates and functions must be converted to strings before being included in a JSON compliant object or string by either function. Implicit conversion by parse() and stringify() will preserve the information of a date, but will not preserve any of a function. Functions may be preserved by saving them as a string, then run using eval()

    const dynamic = {1: "A", 2: new Date(), 3 : function () {return "C";}};
    const static = JSON.stringify(dynamic);

    console.log(static)
    // Will return '{1: "A", 2: < whatever the date was when you created static>}'

    console.log(dynamic)
    // '{1: "A", 2: < whatever the date was when you logged dynamic to console >, 3 : "C"}'

Parse() accepts a second argument, called a reviver, which allows each property to be checked before returning the value. That is to say that the reviver argument is generally a function for validation and sanitation.

## Q13 For the code snippet provided below, write comments for each line of code to explain its functionality. In your comments you must demonstrates your ability to recognise and identify functions, ranges and classes

    // tldr;
    // two classes with nested logging functions and constructor functions
    // that construct objects with three defined properties, one on each class and
    // one being the subclass
    // a function for selecting random integers in a range
    // and an each function for triggering the logging functions on the classes
    // with values for the class properties randomly selected from some predefined arrays
    // probably with an error in the selection statement for one of the properties (models)
    // and with an inaccuracy in the random int generation algorithm

    class Car { // declares a new class called car
        constructor(brand) { // declares a constructor function
                            // for an object of class car that will take brand as an argument
        this.carname = brand; // sets the newly created car's carname to the value of brand
        }
        present() { // defines a car method called present that returns the string and carname (below)
        return 'I have a ' + this.carname;
        }
    }
    // the overall purpose of the car class is to hold a constructor that sets the carname
    // of a newly created car to its brand, then returns a string which includes that carname and some sugaring
    
    class Model extends Car { // extend the car class with a model class
        constructor(brand, mod) { // constructor function accepts brand and mod as arguments
        super(brand); // access and call the functions of Car through brand
        this.model = mod; // set the model of the constructed model to the arg mod
        }
        show() { // define a model method called show that calls the car present method
                // and then adds some more sugar and the value of the mod argument
        return this.present() + ', it was made in ' + this.model;
        }
    }
    
    let makes = ["Ford", "Holden", "Toyota"] // declare an array of strings called makes
    let models = Array.from(new Array(40), (x,i) => i + 1980)
    // declare an array called models which contains the range of integers 1980..2019
    // generated by iterating i+1980 40 times with i starting at 0


    function randomIntFromInterval(min,max) { // declare a function called randomIntFromInterval
        return Math.floor(Math.random()*(max-min+1)+min);
        // floor to make rtn integer
        // random to randomise
        // *(max-min+1)+min to set range within the provided max and min
    } // ie. returns an random integer within a range for floor min and ceiling max
    // except some probably unintentional behaviour exists;
    // if given a non-int for min it can return a value outside the input range
    // for this application it doesn't matter, but this function isn't too flexible
    
    for (model of models) { // iterate through the models array
    
        make = makes[randomIntFromInterval(0,makes.length-1)]
        // select a value from the makes array randomly with the possible values by
        // feeding the 0 and the length of the array from which we want to select randomly
        // as arguments to the randomIntFromInterval function
        model = models[randomIntFromInterval(0,makes.length-1)]
        // and do as above comments, but for the models array
        // using the length of makes instead of the length of models so that our selection is constrained
        // to the first n=makes.len of the range
        // probably unintentional behaviour... probably the max arg is meant to be to models.len 
    
        mycar = new Model(make, model);
        // then feed both of the randomly selected values to the Model class' constructor functions
        // to construct a car with a model and carname attribute 
        console.log(mycar.show())
        // and then call the show function on model to trigger it and present to output a string that shows
        // our randomly selected info
    }

## Attributions
Atlassian (n.d.). Source Code Management | Atlassian Git Tutorial. [online] Atlassian. Available at: https://www.atlassian.com/git/tutorials/source-code-management.

Chappel, David (n.d.). The Three Aspects of Software Quality v1.0 [online] Available at: http://www.davidchappell.com/writing/white_papers/The_Three_Aspects_of_Software_Quality_v1.0-Chappell.pdf.

MongoDB (n.d.). What is the MERN Stack? Introduction & Examples. [online] MongoDB. Available at: https://www.mongodb.com/mern-stack.

MongoDB (n.d.). Structure your Data for MongoDB. [online] Available at: https://www.mongodb.com/docs/guides/server/introduction/.

AIT (n.d.). T3A2-A Full Stack App Part A. [online] AIT. Available at: https://ait.instructure.com/courses/3801/assignments/41802.

AIT (n.d.). T3A2-B Full Stack App Part B. [online] AIT. Available at: https://ait.instructure.com/courses/3801/assignments/41803.

W3schools.com. (2019). JSON.parse(). [online] Available at: https://www.w3schools.com/Js/js_json_parse.asp.
